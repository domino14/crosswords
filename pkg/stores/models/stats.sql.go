// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: stats.sql

package models

import (
	"context"
)

const getHeadToHead = `-- name: GetHeadToHead :one
SELECT
  SUM(wins) AS player_wins,
  SUM(losses) AS player_losses,
  SUM(draws) AS player_draws,
  SUM(our_bingos) AS our_total_bingos,
  SUM(their_bingos) AS their_total_bingos,
  SUM(our_tiles_played) AS our_total_tiles_played,
  SUM(their_tiles_played) AS their_total_tiles_played,
  SUM(our_blanks_played) AS our_total_blanks_played,
  SUM(their_blanks_played) AS their_total_blanks_played,
  SUM(score_difference) AS spread
FROM
  (SELECT
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd1' ELSE 'd2' END->'Wins'->>'t')::int AS wins,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd1' ELSE 'd2' END->'Losses'->>'t')::int AS losses,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd1' ELSE 'd2' END->'Draws'->>'t')::int AS draws,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd1' ELSE 'd2' END->'Bingos'->>'t')::int AS our_bingos,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd2' ELSE 'd1' END->'Bingos'->>'t')::int AS their_bingos,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd1' ELSE 'd2' END->'Tiles Played'->>'t')::int AS our_tiles_played,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd2' ELSE 'd1' END->'Tiles Played'->>'t')::int AS their_tiles_played,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd1' ELSE 'd2' END->'Tiles Played'->'s'->>'?')::int AS our_blanks_played,
     (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd2' ELSE 'd1' END->'Tiles Played'->'s'->>'?')::int AS their_blanks_played,

     ((stats->CASE WHEN stats->>'i1' = $3::text THEN 'd1' ELSE 'd2' END->'Score'->>'t')::int -
      (stats->CASE WHEN stats->>'i1' = $3::text THEN 'd2' ELSE 'd1' END->'Score'->>'t')::int) AS score_difference
   FROM
     games
   INNER JOIN users u1 ON games.player0_id = u1.id
   INNER JOIN users u2 ON games.player1_id = u2.id
   WHERE
     (u1.uuid = $3 AND u2.uuid = $4::text) OR
     (u1.uuid = $4::text AND u2.uuid = $3)
   ORDER BY
     games.created_at DESC
   LIMIT $1
   OFFSET $2
  ) AS aggregated_stats
`

type GetHeadToHeadParams struct {
	Limit  int32
	Offset int32
	P1uuid string
	P2uuid string
}

type GetHeadToHeadRow struct {
	PlayerWins             int64
	PlayerLosses           int64
	PlayerDraws            int64
	OurTotalBingos         int64
	TheirTotalBingos       int64
	OurTotalTilesPlayed    int64
	TheirTotalTilesPlayed  int64
	OurTotalBlanksPlayed   int64
	TheirTotalBlanksPlayed int64
	Spread                 int64
}

func (q *Queries) GetHeadToHead(ctx context.Context, arg GetHeadToHeadParams) (GetHeadToHeadRow, error) {
	row := q.db.QueryRow(ctx, getHeadToHead,
		arg.Limit,
		arg.Offset,
		arg.P1uuid,
		arg.P2uuid,
	)
	var i GetHeadToHeadRow
	err := row.Scan(
		&i.PlayerWins,
		&i.PlayerLosses,
		&i.PlayerDraws,
		&i.OurTotalBingos,
		&i.TheirTotalBingos,
		&i.OurTotalTilesPlayed,
		&i.TheirTotalTilesPlayed,
		&i.OurTotalBlanksPlayed,
		&i.TheirTotalBlanksPlayed,
		&i.Spread,
	)
	return i, err
}

const getHighestTurnsFromGameUUIDs = `-- name: GetHighestTurnsFromGameUUIDs :many
select user_uuid, max(high_turn) high_turn
from
  (
    select stats->>'i1' user_uuid, (stats->'d1'->'High Turn'->>'t')::int high_turn
    from games
    where uuid = ANY ($1::text[])
  union all
    select stats->>'i2' user_uuid, (stats->'d2'->'High Turn'->>'t')::int high_turn
    from games
    where uuid = ANY ($1::text[])
  ) t
group by user_uuid
order by high_turn desc
`

type GetHighestTurnsFromGameUUIDsRow struct {
	UserUuid interface{}
	HighTurn interface{}
}

func (q *Queries) GetHighestTurnsFromGameUUIDs(ctx context.Context, dollar_1 []string) ([]GetHighestTurnsFromGameUUIDsRow, error) {
	rows, err := q.db.Query(ctx, getHighestTurnsFromGameUUIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHighestTurnsFromGameUUIDsRow
	for rows.Next() {
		var i GetHighestTurnsFromGameUUIDsRow
		if err := rows.Scan(&i.UserUuid, &i.HighTurn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalBingosFromGameUUIDs = `-- name: GetTotalBingosFromGameUUIDs :many
select user_uuid, sum(bingos) total_bingos
from
  (
    select stats->>'i1' user_uuid, (stats->'d1'->'Bingos'->>'t')::int bingos
    from games
    where uuid = ANY ($1::text[])
  union all
    select stats->>'i2' user_uuid, (stats->'d2'->'Bingos'->>'t')::int bingos
    from games
    where uuid = ANY ($1::text[])
  ) t
group by user_uuid
order by total_bingos desc
`

type GetTotalBingosFromGameUUIDsRow struct {
	UserUuid    interface{}
	TotalBingos int64
}

func (q *Queries) GetTotalBingosFromGameUUIDs(ctx context.Context, dollar_1 []string) ([]GetTotalBingosFromGameUUIDsRow, error) {
	rows, err := q.db.Query(ctx, getTotalBingosFromGameUUIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalBingosFromGameUUIDsRow
	for rows.Next() {
		var i GetTotalBingosFromGameUUIDsRow
		if err := rows.Scan(&i.UserUuid, &i.TotalBingos); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
