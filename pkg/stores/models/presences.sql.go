// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: presences.sql

package models

import (
	"context"
	"database/sql"
)

const addConnection = `-- name: AddConnection :execrows
INSERT INTO public.user_channel_presences (user_id, channel_name, connection_id)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type AddConnectionParams struct {
	UserID       string
	ChannelName  string
	ConnectionID string
}

func (q *Queries) AddConnection(ctx context.Context, arg AddConnectionParams) (int64, error) {
	result, err := q.db.Exec(ctx, addConnection, arg.UserID, arg.ChannelName, arg.ConnectionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteConnection = `-- name: DeleteConnection :execrows
DELETE FROM public.user_channel_presences
WHERE connection_id = $1
`

func (q *Queries) DeleteConnection(ctx context.Context, connectionID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteConnection, connectionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExpiredConnections = `-- name: DeleteExpiredConnections :exec
DELETE FROM public.user_channel_presences
WHERE date_trunc('hour', last_seen_at) < date_trunc('hour', now() - interval '2 hours')
`

func (q *Queries) DeleteExpiredConnections(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredConnections)
	return err
}

const getAllFollowedUsers = `-- name: GetAllFollowedUsers :many
SELECT user_channel_presences.user_id, channel_name 
FROM public.user_channel_presences
JOIN users ON users.uuid = user_channel_presences.user_id
LEFT OUTER JOIN followings ON users.id = followings.user_id
WHERE followings.follower_id = $1
`

type GetAllFollowedUsersRow struct {
	UserID      string
	ChannelName string
}

// "Get me all the users that are followed by $1."
func (q *Queries) GetAllFollowedUsers(ctx context.Context, followerID sql.NullInt32) ([]GetAllFollowedUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllFollowedUsers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFollowedUsersRow
	for rows.Next() {
		var i GetAllFollowedUsersRow
		if err := rows.Scan(&i.UserID, &i.ChannelName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOnlineFollowedUsers = `-- name: GetOnlineFollowedUsers :many

SELECT user_channel_presences.user_id, channel_name 
FROM public.user_channel_presences
JOIN users ON users.uuid = user_channel_presences.user_id
JOIN followings ON users.id = followings.user_id
WHERE followings.follower_id = $1
`

type GetOnlineFollowedUsersRow struct {
	UserID      string
	ChannelName string
}

// presence stuff
// "Get me the users that are followed by $1 that are online"
func (q *Queries) GetOnlineFollowedUsers(ctx context.Context, followerID sql.NullInt32) ([]GetOnlineFollowedUsersRow, error) {
	rows, err := q.db.Query(ctx, getOnlineFollowedUsers, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOnlineFollowedUsersRow
	for rows.Next() {
		var i GetOnlineFollowedUsersRow
		if err := rows.Scan(&i.UserID, &i.ChannelName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOnlineFollowersOf = `-- name: GetOnlineFollowersOf :many
SELECT user_channel_presences.user_id
FROM public.user_channel_presences
JOIN users ON users.uuid = user_channel_presences.user_id
JOIN followings ON users.id = followings.follower_id
WHERE followings.user_id = $1
`

// "Get me the followers of $1 that are online"
func (q *Queries) GetOnlineFollowersOf(ctx context.Context, userID sql.NullInt32) ([]string, error) {
	rows, err := q.db.Query(ctx, getOnlineFollowersOf, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersInChannel = `-- name: GetUsersInChannel :many
SELECT user_id
FROM public.user_channel_presences
WHERE channel_name = $1
`

func (q *Queries) GetUsersInChannel(ctx context.Context, channelName string) ([]string, error) {
	rows, err := q.db.Query(ctx, getUsersInChannel, channelName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUniqueChannelsNotMatching = `-- name: SelectUniqueChannelsNotMatching :many
SELECT DISTINCT channel_name FROM public.user_channel_presences
WHERE user_id = $1
AND (channel_name, connection_id) != ($2, $3)
`

type SelectUniqueChannelsNotMatchingParams struct {
	UserID       string
	ChannelName  string
	ConnectionID string
}

func (q *Queries) SelectUniqueChannelsNotMatching(ctx context.Context, arg SelectUniqueChannelsNotMatchingParams) ([]string, error) {
	rows, err := q.db.Query(ctx, selectUniqueChannelsNotMatching, arg.UserID, arg.ChannelName, arg.ConnectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var channel_name string
		if err := rows.Scan(&channel_name); err != nil {
			return nil, err
		}
		items = append(items, channel_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLastSeen = `-- name: UpdateLastSeen :exec
UPDATE public.user_channel_presences
SET last_seen_at = now()
WHERE connection_id = $1
`

func (q *Queries) UpdateLastSeen(ctx context.Context, connectionID string) error {
	_, err := q.db.Exec(ctx, updateLastSeen, connectionID)
	return err
}
