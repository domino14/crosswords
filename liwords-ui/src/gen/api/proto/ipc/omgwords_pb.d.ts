// messages related to the omgwords game, used mainly by IPC
// note: omgwords is the crossword board game, and includes variants dogworms,
// superomgwords, etc etc

// @generated by protoc-gen-es v1.10.0
// @generated from file proto/ipc/omgwords.proto (package ipc, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { BotRequest_BotCode, ChallengeRule as ChallengeRule$1, GameEvent as GameEvent$1, GameHistory, PlayState as PlayState$1 } from "../../vendor/macondo/macondo_pb.js";

/**
 * @generated from enum ipc.GameEndReason
 */
export declare enum GameEndReason {
  /**
   * NONE: the game has not yet ended!
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * TIME: one person timed out (and lost)
   *
   * @generated from enum value: TIME = 1;
   */
  TIME = 1,

  /**
   * WENT_OUT: game ended regularly, with one person having zero tiles on their
   * rack.
   *
   * @generated from enum value: STANDARD = 2;
   */
  STANDARD = 2,

  /**
   * 6 consecutive zeroes ends the game.
   *
   * @generated from enum value: CONSECUTIVE_ZEROES = 3;
   */
  CONSECUTIVE_ZEROES = 3,

  /**
   * @generated from enum value: RESIGNED = 4;
   */
  RESIGNED = 4,

  /**
   * Aborted games are aborted by mutual agreement.
   *
   * @generated from enum value: ABORTED = 5;
   */
  ABORTED = 5,

  /**
   * @generated from enum value: TRIPLE_CHALLENGE = 6;
   */
  TRIPLE_CHALLENGE = 6,

  /**
   * CANCELLED means the game never started. Game start signal was not sent.
   *
   * @generated from enum value: CANCELLED = 7;
   */
  CANCELLED = 7,

  /**
   * FORCE_FORFEIT is a way to force an opponent to take a loss if they left a
   * game early without resigning.
   *
   * @generated from enum value: FORCE_FORFEIT = 8;
   */
  FORCE_FORFEIT = 8,
}

/**
 * @generated from enum ipc.GameMode
 */
export declare enum GameMode {
  /**
   * @generated from enum value: REAL_TIME = 0;
   */
  REAL_TIME = 0,

  /**
   * @generated from enum value: CORRESPONDENCE = 1;
   */
  CORRESPONDENCE = 1,
}

/**
 * @generated from enum ipc.RatingMode
 */
export declare enum RatingMode {
  /**
   * @generated from enum value: RATED = 0;
   */
  RATED = 0,

  /**
   * @generated from enum value: CASUAL = 1;
   */
  CASUAL = 1,
}

/**
 * @generated from enum ipc.GameType
 */
export declare enum GameType {
  /**
   * A NATIVE game is the default OMGWords game (or its variants)
   * created on the woogles site, between two players or between a player
   * and a bot.
   *
   * @generated from enum value: NATIVE = 0;
   */
  NATIVE = 0,

  /**
   * An ANNOTATED game does not feature Woogles players, but is instead
   * created by a broadcaster/annotator to represent a real-life game.
   * It is created using the liwords "editor" mode or by importing a GCG.
   *
   * @generated from enum value: ANNOTATED = 1;
   */
  ANNOTATED = 1,

  /**
   * @generated from enum value: BOT_VS_BOT = 2;
   */
  BOT_VS_BOT = 2,
}

/**
 * @generated from enum ipc.PlayState
 */
export declare enum PlayState {
  /**
   * @generated from enum value: PLAYING = 0;
   */
  PLAYING = 0,

  /**
   * @generated from enum value: WAITING_FOR_FINAL_PASS = 1;
   */
  WAITING_FOR_FINAL_PASS = 1,

  /**
   * @generated from enum value: GAME_OVER = 2;
   */
  GAME_OVER = 2,

  /**
   * @generated from enum value: UNSTARTED = 3;
   */
  UNSTARTED = 3,
}

/**
 * @generated from enum ipc.ChallengeRule
 */
export declare enum ChallengeRule {
  /**
   * @generated from enum value: ChallengeRule_VOID = 0;
   */
  ChallengeRule_VOID = 0,

  /**
   * @generated from enum value: ChallengeRule_SINGLE = 1;
   */
  ChallengeRule_SINGLE = 1,

  /**
   * @generated from enum value: ChallengeRule_DOUBLE = 2;
   */
  ChallengeRule_DOUBLE = 2,

  /**
   * @generated from enum value: ChallengeRule_FIVE_POINT = 3;
   */
  ChallengeRule_FIVE_POINT = 3,

  /**
   * @generated from enum value: ChallengeRule_TEN_POINT = 4;
   */
  ChallengeRule_TEN_POINT = 4,

  /**
   * @generated from enum value: ChallengeRule_TRIPLE = 5;
   */
  ChallengeRule_TRIPLE = 5,
}

/**
 * @generated from message ipc.ClientGameplayEvent
 */
export declare class ClientGameplayEvent extends Message<ClientGameplayEvent> {
  /**
   * @generated from field: ipc.ClientGameplayEvent.EventType type = 1;
   */
  type: ClientGameplayEvent_EventType;

  /**
   * @generated from field: string game_id = 2;
   */
  gameId: string;

  /**
   * position coordinates, like H8 or G10. Only matters for TILE_PLACEMENT.
   *
   * @generated from field: string position_coords = 3;
   */
  positionCoords: string;

  /**
   * tiles that are being played (or exchanged). The `.` character is used
   * for thru, and lowercase characters are used for blanks.
   *
   * @generated from field: string tiles = 4 [deprecated = true];
   * @deprecated
   */
  tiles: string;

  /**
   * machine_letters is tiles, but in binary.
   *
   * @generated from field: bytes machine_letters = 5;
   */
  machineLetters: Uint8Array;

  constructor(data?: PartialMessage<ClientGameplayEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.ClientGameplayEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientGameplayEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientGameplayEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientGameplayEvent;

  static equals(a: ClientGameplayEvent | PlainMessage<ClientGameplayEvent> | undefined, b: ClientGameplayEvent | PlainMessage<ClientGameplayEvent> | undefined): boolean;
}

/**
 * @generated from enum ipc.ClientGameplayEvent.EventType
 */
export declare enum ClientGameplayEvent_EventType {
  /**
   * @generated from enum value: TILE_PLACEMENT = 0;
   */
  TILE_PLACEMENT = 0,

  /**
   * @generated from enum value: PASS = 1;
   */
  PASS = 1,

  /**
   * @generated from enum value: EXCHANGE = 2;
   */
  EXCHANGE = 2,

  /**
   * @generated from enum value: CHALLENGE_PLAY = 3;
   */
  CHALLENGE_PLAY = 3,

  /**
   * @generated from enum value: RESIGN = 4;
   */
  RESIGN = 4,
}

/**
 * A GameRules is just the name of a board layout + the name of a letter
 * distribution. These must exist in a database or file somewhere.
 *
 * @generated from message ipc.GameRules
 */
export declare class GameRules extends Message<GameRules> {
  /**
   * The supported board layout names are CrosswordGame and SuperCrosswordGame
   *
   * @generated from field: string board_layout_name = 1;
   */
  boardLayoutName: string;

  /**
   * The supported letter distributions are english, french, norwegian, german,
   * catalan. There are more to come!
   *
   * @generated from field: string letter_distribution_name = 2;
   */
  letterDistributionName: string;

  /**
   * Use "classic" for our classic game, otherwise it could be some other game
   * (a is worth 100, dogworms, etc.)
   *
   * @generated from field: string variant_name = 3;
   */
  variantName: string;

  constructor(data?: PartialMessage<GameRules>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameRules";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameRules;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameRules;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameRules;

  static equals(a: GameRules | PlainMessage<GameRules> | undefined, b: GameRules | PlainMessage<GameRules> | undefined): boolean;
}

/**
 * @generated from message ipc.GameRequest
 */
export declare class GameRequest extends Message<GameRequest> {
  /**
   * @generated from field: string lexicon = 1;
   */
  lexicon: string;

  /**
   * @generated from field: ipc.GameRules rules = 2;
   */
  rules?: GameRules;

  /**
   * @generated from field: int32 initial_time_seconds = 3;
   */
  initialTimeSeconds: number;

  /**
   * @generated from field: int32 increment_seconds = 4;
   */
  incrementSeconds: number;

  /**
   * @generated from field: macondo.ChallengeRule challenge_rule = 5;
   */
  challengeRule: ChallengeRule$1;

  /**
   * @generated from field: ipc.GameMode game_mode = 6;
   */
  gameMode: GameMode;

  /**
   * @generated from field: ipc.RatingMode rating_mode = 7;
   */
  ratingMode: RatingMode;

  /**
   * @generated from field: string request_id = 8;
   */
  requestId: string;

  /**
   * @generated from field: int32 max_overtime_minutes = 9;
   */
  maxOvertimeMinutes: number;

  /**
   * @generated from field: bool player_vs_bot = 10;
   */
  playerVsBot: boolean;

  /**
   * @generated from field: string original_request_id = 11;
   */
  originalRequestId: string;

  /**
   * @generated from field: macondo.BotRequest.BotCode bot_type = 12;
   */
  botType: BotRequest_BotCode;

  constructor(data?: PartialMessage<GameRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameRequest;

  static equals(a: GameRequest | PlainMessage<GameRequest> | undefined, b: GameRequest | PlainMessage<GameRequest> | undefined): boolean;
}

/**
 * GameMetaEvent defines how we serialize meta events to the database.
 *
 * @generated from message ipc.GameMetaEvent
 */
export declare class GameMetaEvent extends Message<GameMetaEvent> {
  /**
   * @generated from field: string orig_event_id = 1;
   */
  origEventId: string;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: ipc.GameMetaEvent.EventType type = 3;
   */
  type: GameMetaEvent_EventType;

  /**
   * the player that performed the event.
   *
   * @generated from field: string player_id = 4;
   */
  playerId: string;

  /**
   * @generated from field: string game_id = 5;
   */
  gameId: string;

  /**
   * how long should this event remain active, in milliseconds?
   *
   * @generated from field: int32 expiry = 6;
   */
  expiry: number;

  constructor(data?: PartialMessage<GameMetaEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameMetaEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameMetaEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameMetaEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameMetaEvent;

  static equals(a: GameMetaEvent | PlainMessage<GameMetaEvent> | undefined, b: GameMetaEvent | PlainMessage<GameMetaEvent> | undefined): boolean;
}

/**
 * @generated from enum ipc.GameMetaEvent.EventType
 */
export declare enum GameMetaEvent_EventType {
  /**
   * These are "original events"
   *
   * @generated from enum value: REQUEST_ABORT = 0;
   */
  REQUEST_ABORT = 0,

  /**
   * Adjudication is just seen as a "nudge" on the front end.
   *
   * @generated from enum value: REQUEST_ADJUDICATION = 1;
   */
  REQUEST_ADJUDICATION = 1,

  /**
   * @generated from enum value: REQUEST_UNDO = 2;
   */
  REQUEST_UNDO = 2,

  /**
   * Are we going to implement this someday?
   *
   * @generated from enum value: REQUEST_ADJOURN = 3;
   */
  REQUEST_ADJOURN = 3,

  /**
   * And these are responses:
   * A user can accept an abort, or the client will auto-accept when time
   * expires:
   *
   * @generated from enum value: ABORT_ACCEPTED = 4;
   */
  ABORT_ACCEPTED = 4,

  /**
   * @generated from enum value: ABORT_DENIED = 5;
   */
  ABORT_DENIED = 5,

  /**
   * A user would not accept an adjudication. The client auto-accepts this
   * when time expires
   *
   * @generated from enum value: ADJUDICATION_ACCEPTED = 6;
   */
  ADJUDICATION_ACCEPTED = 6,

  /**
   * An adjudication is denied when the receiver responds positively to a
   * nudge.
   *
   * @generated from enum value: ADJUDICATION_DENIED = 7;
   */
  ADJUDICATION_DENIED = 7,

  /**
   * @generated from enum value: UNDO_ACCEPTED = 8;
   */
  UNDO_ACCEPTED = 8,

  /**
   * @generated from enum value: UNDO_DENIED = 9;
   */
  UNDO_DENIED = 9,

  /**
   * More:
   *
   * add X seconds at a time (30?) to opponent's clock
   *
   * @generated from enum value: ADD_TIME = 10;
   */
  ADD_TIME = 10,

  /**
   * Some meta events have a timer associated with them. Send this with the
   * original event id after time has expired.
   *
   * @generated from enum value: TIMER_EXPIRED = 11;
   */
  TIMER_EXPIRED = 11,
}

/**
 * A GameHistoryRefresher is sent to both players when the game starts,
 * and any observers at the time that they begin observing. It can also be sent
 * to a player who reconnects in the middle of a game.
 *
 * @generated from message ipc.GameHistoryRefresher
 */
export declare class GameHistoryRefresher extends Message<GameHistoryRefresher> {
  /**
   * The history contains all the moves, points, as well as the last known racks
   * of each player. It also implicitly contains whose turn it is at the moment,
   * by the events / turns in the history.
   * The front-end is responsible for showing all this information in a nice
   * format.
   * Note: the racks of each player should not be sent to both players, only
   * to observers. The back-end will have to be smart enough to overwrite
   * this information with a blank string before sending it. It might not
   * even be that great of a big deal, as I'm sure people can devise other ways
   * to cheat, but shrug.
   *
   * @generated from field: macondo.GameHistory history = 1;
   */
  history?: GameHistory;

  /**
   * These represent how much time each player has remaining on their clock
   * as of the "refresher", in milliseconds.
   * player1 is the player who is listed first in the game history, regardless
   * of whether they went first.
   *
   * @generated from field: int32 time_player1 = 2;
   */
  timePlayer1: number;

  /**
   * @generated from field: int32 time_player2 = 3;
   */
  timePlayer2: number;

  /**
   * @generated from field: int32 max_overtime_minutes = 4;
   */
  maxOvertimeMinutes: number;

  /**
   * outstanding_event refers to any possible outstanding game meta event that
   * has not yet been responded to or expired.
   *
   * @generated from field: ipc.GameMetaEvent outstanding_event = 5;
   */
  outstandingEvent?: GameMetaEvent;

  constructor(data?: PartialMessage<GameHistoryRefresher>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameHistoryRefresher";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameHistoryRefresher;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameHistoryRefresher;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameHistoryRefresher;

  static equals(a: GameHistoryRefresher | PlainMessage<GameHistoryRefresher> | undefined, b: GameHistoryRefresher | PlainMessage<GameHistoryRefresher> | undefined): boolean;
}

/**
 * A GameDocumentEvent should eventually replace the GameHistoryRefresher. For
 * now, it will be used for annotated games.
 *
 * @generated from message ipc.GameDocumentEvent
 */
export declare class GameDocumentEvent extends Message<GameDocumentEvent> {
  /**
   * @generated from field: ipc.GameDocument doc = 1;
   */
  doc?: GameDocument;

  constructor(data?: PartialMessage<GameDocumentEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameDocumentEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameDocumentEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameDocumentEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameDocumentEvent;

  static equals(a: GameDocumentEvent | PlainMessage<GameDocumentEvent> | undefined, b: GameDocumentEvent | PlainMessage<GameDocumentEvent> | undefined): boolean;
}

/**
 * @generated from message ipc.TournamentDataForGame
 */
export declare class TournamentDataForGame extends Message<TournamentDataForGame> {
  /**
   * The ID of the tournament
   *
   * @generated from field: string tid = 1;
   */
  tid: string;

  /**
   * @generated from field: string division = 2;
   */
  division: string;

  /**
   * @generated from field: int32 round = 3;
   */
  round: number;

  /**
   * @generated from field: int32 game_index = 4;
   */
  gameIndex: number;

  constructor(data?: PartialMessage<TournamentDataForGame>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.TournamentDataForGame";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TournamentDataForGame;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TournamentDataForGame;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TournamentDataForGame;

  static equals(a: TournamentDataForGame | PlainMessage<TournamentDataForGame> | undefined, b: TournamentDataForGame | PlainMessage<TournamentDataForGame> | undefined): boolean;
}

/**
 * Meta information about the player of a particular game.
 *
 * @generated from message ipc.PlayerInfo
 */
export declare class PlayerInfo extends Message<PlayerInfo> {
  /**
   * @generated from field: string user_id = 1;
   */
  userId: string;

  /**
   * @generated from field: string nickname = 2;
   */
  nickname: string;

  /**
   * @generated from field: string full_name = 3;
   */
  fullName: string;

  /**
   * @generated from field: string country_code = 4;
   */
  countryCode: string;

  /**
   * Rating for the particular mode of the game. String because it could be
   * provisional or some other strings.
   *
   * @generated from field: string rating = 5;
   */
  rating: string;

  /**
   * @generated from field: string title = 6;
   */
  title: string;

  /**
   * string avatar_url = 7; // the UserService now offers Avatar info
   *
   * @generated from field: bool is_bot = 8;
   */
  isBot: boolean;

  /**
   * first is true if the player went first. This is deprecated because it
   * is assumed the player listed first went first.
   *
   * @generated from field: bool first = 9 [deprecated = true];
   * @deprecated
   */
  first: boolean;

  constructor(data?: PartialMessage<PlayerInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.PlayerInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerInfo;

  static equals(a: PlayerInfo | PlainMessage<PlayerInfo> | undefined, b: PlayerInfo | PlainMessage<PlayerInfo> | undefined): boolean;
}

/**
 * @generated from message ipc.GameInfoResponse
 */
export declare class GameInfoResponse extends Message<GameInfoResponse> {
  /**
   * @generated from field: repeated ipc.PlayerInfo players = 1;
   */
  players: PlayerInfo[];

  /**
   * @generated from field: string time_control_name = 4;
   */
  timeControlName: string;

  /**
   * @generated from field: string tournament_id = 6;
   */
  tournamentId: string;

  /**
   * done - is game done?
   * bool done = 9;
   *
   * @generated from field: ipc.GameEndReason game_end_reason = 11;
   */
  gameEndReason: GameEndReason;

  /**
   * @generated from field: repeated int32 scores = 13;
   */
  scores: number[];

  /**
   * @generated from field: int32 winner = 14;
   */
  winner: number;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 15;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: string game_id = 16;
   */
  gameId: string;

  /**
   * @generated from field: google.protobuf.Timestamp last_update = 18;
   */
  lastUpdate?: Timestamp;

  /**
   * @generated from field: ipc.GameRequest game_request = 19;
   */
  gameRequest?: GameRequest;

  /**
   * @generated from field: string tournament_division = 20;
   */
  tournamentDivision: string;

  /**
   * @generated from field: int32 tournament_round = 21;
   */
  tournamentRound: number;

  /**
   * a game index within a round.
   *
   * @generated from field: int32 tournament_game_index = 22;
   */
  tournamentGameIndex: number;

  /**
   * @generated from field: ipc.GameType type = 23;
   */
  type: GameType;

  constructor(data?: PartialMessage<GameInfoResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameInfoResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameInfoResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameInfoResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameInfoResponse;

  static equals(a: GameInfoResponse | PlainMessage<GameInfoResponse> | undefined, b: GameInfoResponse | PlainMessage<GameInfoResponse> | undefined): boolean;
}

/**
 * @generated from message ipc.GameInfoResponses
 */
export declare class GameInfoResponses extends Message<GameInfoResponses> {
  /**
   * @generated from field: repeated ipc.GameInfoResponse game_info = 1;
   */
  gameInfo: GameInfoResponse[];

  constructor(data?: PartialMessage<GameInfoResponses>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameInfoResponses";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameInfoResponses;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameInfoResponses;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameInfoResponses;

  static equals(a: GameInfoResponses | PlainMessage<GameInfoResponses> | undefined, b: GameInfoResponses | PlainMessage<GameInfoResponses> | undefined): boolean;
}

/**
 * InstantiateGame is an internal message passed to gamesvc in order to
 * instantiate a game.
 *
 * @generated from message ipc.InstantiateGame
 */
export declare class InstantiateGame extends Message<InstantiateGame> {
  /**
   * @generated from field: repeated string user_ids = 1;
   */
  userIds: string[];

  /**
   * @generated from field: ipc.GameRequest game_request = 2;
   */
  gameRequest?: GameRequest;

  /**
   * assigned_first is -1 if random, or the player index in user_ids otherwise
   *
   * @generated from field: int32 assigned_first = 3;
   */
  assignedFirst: number;

  /**
   * @generated from field: ipc.TournamentDataForGame tournament_data = 4;
   */
  tournamentData?: TournamentDataForGame;

  constructor(data?: PartialMessage<InstantiateGame>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.InstantiateGame";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstantiateGame;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstantiateGame;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstantiateGame;

  static equals(a: InstantiateGame | PlainMessage<InstantiateGame> | undefined, b: InstantiateGame | PlainMessage<InstantiateGame> | undefined): boolean;
}

/**
 * @generated from message ipc.GameDeletion
 */
export declare class GameDeletion extends Message<GameDeletion> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  constructor(data?: PartialMessage<GameDeletion>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameDeletion";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameDeletion;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameDeletion;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameDeletion;

  static equals(a: GameDeletion | PlainMessage<GameDeletion> | undefined, b: GameDeletion | PlainMessage<GameDeletion> | undefined): boolean;
}

/**
 * @generated from message ipc.ActiveGamePlayer
 */
export declare class ActiveGamePlayer extends Message<ActiveGamePlayer> {
  /**
   * @generated from field: string username = 1;
   */
  username: string;

  /**
   * @generated from field: string user_id = 2;
   */
  userId: string;

  constructor(data?: PartialMessage<ActiveGamePlayer>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.ActiveGamePlayer";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveGamePlayer;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveGamePlayer;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveGamePlayer;

  static equals(a: ActiveGamePlayer | PlainMessage<ActiveGamePlayer> | undefined, b: ActiveGamePlayer | PlainMessage<ActiveGamePlayer> | undefined): boolean;
}

/**
 * @generated from message ipc.ActiveGameEntry
 */
export declare class ActiveGameEntry extends Message<ActiveGameEntry> {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: repeated ipc.ActiveGamePlayer player = 2;
   */
  player: ActiveGamePlayer[];

  /**
   * time to live, in seconds
   *
   * @generated from field: int64 ttl = 3;
   */
  ttl: bigint;

  constructor(data?: PartialMessage<ActiveGameEntry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.ActiveGameEntry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveGameEntry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveGameEntry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveGameEntry;

  static equals(a: ActiveGameEntry | PlainMessage<ActiveGameEntry> | undefined, b: ActiveGameEntry | PlainMessage<ActiveGameEntry> | undefined): boolean;
}

/**
 * @generated from message ipc.ReadyForGame
 */
export declare class ReadyForGame extends Message<ReadyForGame> {
  /**
   * @generated from field: string game_id = 1;
   */
  gameId: string;

  constructor(data?: PartialMessage<ReadyForGame>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.ReadyForGame";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadyForGame;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadyForGame;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadyForGame;

  static equals(a: ReadyForGame | PlainMessage<ReadyForGame> | undefined, b: ReadyForGame | PlainMessage<ReadyForGame> | undefined): boolean;
}

/**
 * The server will send back a ServerGameplayEvent to a ClientGameplayEvent.
 * The server will also send these asynchronously for opponent gameplay
 * events.
 * XXX: This message type is obsolete and will be replaced by
 * ServerOMGWordsEvent
 *
 * @generated from message ipc.ServerGameplayEvent
 */
export declare class ServerGameplayEvent extends Message<ServerGameplayEvent> {
  /**
   * XXX: move to ipc.GameEvent
   *
   * @generated from field: macondo.GameEvent event = 1;
   */
  event?: GameEvent$1;

  /**
   * @generated from field: string game_id = 2;
   */
  gameId: string;

  /**
   * @generated from field: string new_rack = 3;
   */
  newRack: string;

  /**
   * @generated from field: int32 time_remaining = 4;
   */
  timeRemaining: number;

  /**
   * XXX: move to ipc.PlayState
   *
   * @generated from field: macondo.PlayState playing = 5;
   */
  playing: PlayState$1;

  /**
   * the event has the nickname, but not the userid.
   *
   * @generated from field: string user_id = 6;
   */
  userId: string;

  constructor(data?: PartialMessage<ServerGameplayEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.ServerGameplayEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerGameplayEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerGameplayEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerGameplayEvent;

  static equals(a: ServerGameplayEvent | PlainMessage<ServerGameplayEvent> | undefined, b: ServerGameplayEvent | PlainMessage<ServerGameplayEvent> | undefined): boolean;
}

/**
 * ServerOMGWordsEvent is a new event type.
 *
 * @generated from message ipc.ServerOMGWordsEvent
 */
export declare class ServerOMGWordsEvent extends Message<ServerOMGWordsEvent> {
  /**
   * @generated from field: ipc.GameEvent event = 1;
   */
  event?: GameEvent;

  /**
   * @generated from field: string game_id = 2;
   */
  gameId: string;

  /**
   * @generated from field: bytes new_rack = 3;
   */
  newRack: Uint8Array;

  /**
   * @generated from field: int32 time_remaining = 4;
   */
  timeRemaining: number;

  /**
   * @generated from field: ipc.PlayState playing = 5;
   */
  playing: PlayState;

  /**
   * @generated from field: string user_id = 6;
   */
  userId: string;

  constructor(data?: PartialMessage<ServerOMGWordsEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.ServerOMGWordsEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerOMGWordsEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerOMGWordsEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerOMGWordsEvent;

  static equals(a: ServerOMGWordsEvent | PlainMessage<ServerOMGWordsEvent> | undefined, b: ServerOMGWordsEvent | PlainMessage<ServerOMGWordsEvent> | undefined): boolean;
}

/**
 * The server will send back a challenge result event only in the case of
 * a challenge. In all other cases, the server will send back a
 * ServerGameplayEvent.
 * A ServerChallengeResultEvent is sent back along with a list of
 * ServerGameplayEvents, instead of trying to reconstruct and send the
 * right incremental events. The reason is that the logic is complex and
 * has many special cases, and is already fully implemented in Macondo.
 * We don't wish to re-implement it both in this repo's backend and frontend.
 * XXX: This message type is obsolete, and will be replaced by
 * OMGWordsChallengeResultEvent
 *
 * @generated from message ipc.ServerChallengeResultEvent
 */
export declare class ServerChallengeResultEvent extends Message<ServerChallengeResultEvent> {
  /**
   * @generated from field: bool valid = 1;
   */
  valid: boolean;

  /**
   * @generated from field: string challenger = 2;
   */
  challenger: string;

  /**
   * @generated from field: macondo.ChallengeRule challenge_rule = 3;
   */
  challengeRule: ChallengeRule$1;

  /**
   * @generated from field: string returned_tiles = 4;
   */
  returnedTiles: string;

  constructor(data?: PartialMessage<ServerChallengeResultEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.ServerChallengeResultEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerChallengeResultEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerChallengeResultEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerChallengeResultEvent;

  static equals(a: ServerChallengeResultEvent | PlainMessage<ServerChallengeResultEvent> | undefined, b: ServerChallengeResultEvent | PlainMessage<ServerChallengeResultEvent> | undefined): boolean;
}

/**
 * @generated from message ipc.OMGWordsChallengeResultEvent
 */
export declare class OMGWordsChallengeResultEvent extends Message<OMGWordsChallengeResultEvent> {
  /**
   * @generated from field: bool valid = 1;
   */
  valid: boolean;

  /**
   * @generated from field: string challenger = 2;
   */
  challenger: string;

  /**
   * @generated from field: ipc.ChallengeRule challenge_rule = 3;
   */
  challengeRule: ChallengeRule;

  /**
   * @generated from field: bytes returned_tiles = 4;
   */
  returnedTiles: Uint8Array;

  constructor(data?: PartialMessage<OMGWordsChallengeResultEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.OMGWordsChallengeResultEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OMGWordsChallengeResultEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OMGWordsChallengeResultEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OMGWordsChallengeResultEvent;

  static equals(a: OMGWordsChallengeResultEvent | PlainMessage<OMGWordsChallengeResultEvent> | undefined, b: OMGWordsChallengeResultEvent | PlainMessage<OMGWordsChallengeResultEvent> | undefined): boolean;
}

/**
 * GameEndedEvent is always sent from the server to both clients.
 *
 * @generated from message ipc.GameEndedEvent
 */
export declare class GameEndedEvent extends Message<GameEndedEvent> {
  /**
   * @generated from field: map<string, int32> scores = 1;
   */
  scores: { [key: string]: number };

  /**
   * @generated from field: map<string, int32> new_ratings = 2;
   */
  newRatings: { [key: string]: number };

  /**
   * @generated from field: ipc.GameEndReason end_reason = 3;
   */
  endReason: GameEndReason;

  /**
   * The winner is not always the highest scoring player; one player can
   * time out. The end_reason should make it clear what happened.
   *
   * @generated from field: string winner = 4;
   */
  winner: string;

  /**
   * @generated from field: string loser = 5;
   */
  loser: string;

  /**
   * If it was a tie, the winner and loser above can be interchanged.
   *
   * @generated from field: bool tie = 6;
   */
  tie: boolean;

  /**
   * Time that the game ended
   *
   * @generated from field: int64 time = 7;
   */
  time: bigint;

  /**
   * @generated from field: map<string, int32> rating_deltas = 8;
   */
  ratingDeltas: { [key: string]: number };

  /**
   * Send the full game history again. This will have rack information in it.
   *
   * @generated from field: macondo.GameHistory history = 9;
   */
  history?: GameHistory;

  constructor(data?: PartialMessage<GameEndedEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameEndedEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameEndedEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameEndedEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameEndedEvent;

  static equals(a: GameEndedEvent | PlainMessage<GameEndedEvent> | undefined, b: GameEndedEvent | PlainMessage<GameEndedEvent> | undefined): boolean;
}

/**
 * RematchStartedEvent gets sent to a game for which there is a rematch.
 * It notifies that observers of the game that a rematch has started.
 *
 * @generated from message ipc.RematchStartedEvent
 */
export declare class RematchStartedEvent extends Message<RematchStartedEvent> {
  /**
   * rematch_game_id is the new game ID.
   *
   * @generated from field: string rematch_game_id = 1;
   */
  rematchGameId: string;

  constructor(data?: PartialMessage<RematchStartedEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.RematchStartedEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RematchStartedEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RematchStartedEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RematchStartedEvent;

  static equals(a: RematchStartedEvent | PlainMessage<RematchStartedEvent> | undefined, b: RematchStartedEvent | PlainMessage<RematchStartedEvent> | undefined): boolean;
}

/**
 * A NewGameEvent gets sent from the server to the involved clients when a new
 * game is about to begin. It should follow a SoughtGameProcessEvent.
 *
 * @generated from message ipc.NewGameEvent
 */
export declare class NewGameEvent extends Message<NewGameEvent> {
  /**
   * @generated from field: string game_id = 1;
   */
  gameId: string;

  /**
   * These are the connection IDs of the requesting and accepting users.
   *
   * @generated from field: string requester_cid = 2;
   */
  requesterCid: string;

  /**
   * @generated from field: string accepter_cid = 3;
   */
  accepterCid: string;

  constructor(data?: PartialMessage<NewGameEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.NewGameEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewGameEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewGameEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewGameEvent;

  static equals(a: NewGameEvent | PlainMessage<NewGameEvent> | undefined, b: NewGameEvent | PlainMessage<NewGameEvent> | undefined): boolean;
}

/**
 * @generated from message ipc.TimedOut
 */
export declare class TimedOut extends Message<TimedOut> {
  /**
   * @generated from field: string game_id = 1;
   */
  gameId: string;

  /**
   * @generated from field: string user_id = 2;
   */
  userId: string;

  constructor(data?: PartialMessage<TimedOut>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.TimedOut";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimedOut;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimedOut;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimedOut;

  static equals(a: TimedOut | PlainMessage<TimedOut> | undefined, b: TimedOut | PlainMessage<TimedOut> | undefined): boolean;
}

/**
 * GameEvent is an internal game event, saved in the GameDocument.
 *
 * @generated from message ipc.GameEvent
 */
export declare class GameEvent extends Message<GameEvent> {
  /**
   * @generated from field: string note = 2;
   */
  note: string;

  /**
   * @generated from field: bytes rack = 3;
   */
  rack: Uint8Array;

  /**
   * @generated from field: ipc.GameEvent.Type type = 4;
   */
  type: GameEvent_Type;

  /**
   * @generated from field: int32 cumulative = 5;
   */
  cumulative: number;

  /**
   * @generated from field: int32 row = 6;
   */
  row: number;

  /**
   * @generated from field: int32 column = 7;
   */
  column: number;

  /**
   * @generated from field: ipc.GameEvent.Direction direction = 8;
   */
  direction: GameEvent_Direction;

  /**
   * @generated from field: string position = 9;
   */
  position: string;

  /**
   * @generated from field: bytes played_tiles = 10;
   */
  playedTiles: Uint8Array;

  /**
   * An event will not have all of these; it depends on the type of the event.
   *
   * @generated from field: bytes exchanged = 11;
   */
  exchanged: Uint8Array;

  /**
   * @generated from field: int32 score = 12;
   */
  score: number;

  /**
   * @generated from field: int32 bonus = 13;
   */
  bonus: number;

  /**
   * @generated from field: int32 end_rack_points = 14;
   */
  endRackPoints: number;

  /**
   * @generated from field: int32 lost_score = 15;
   */
  lostScore: number;

  /**
   * @generated from field: bool is_bingo = 16;
   */
  isBingo: boolean;

  /**
   * words_formed is a list of all words made by this play
   *
   * @generated from field: repeated bytes words_formed = 17;
   */
  wordsFormed: Uint8Array[];

  /**
   * @generated from field: int32 millis_remaining = 18;
   */
  millisRemaining: number;

  /**
   * The player who played this move is encoded in player_index. This should
   * be the index in GameDocument.players.
   *
   * @generated from field: uint32 player_index = 19;
   */
  playerIndex: number;

  /**
   * @generated from field: repeated string words_formed_friendly = 20;
   */
  wordsFormedFriendly: string[];

  constructor(data?: PartialMessage<GameEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameEvent;

  static equals(a: GameEvent | PlainMessage<GameEvent> | undefined, b: GameEvent | PlainMessage<GameEvent> | undefined): boolean;
}

/**
 * @generated from enum ipc.GameEvent.Type
 */
export declare enum GameEvent_Type {
  /**
   * @generated from enum value: TILE_PLACEMENT_MOVE = 0;
   */
  TILE_PLACEMENT_MOVE = 0,

  /**
   * @generated from enum value: PHONY_TILES_RETURNED = 1;
   */
  PHONY_TILES_RETURNED = 1,

  /**
   * @generated from enum value: PASS = 2;
   */
  PASS = 2,

  /**
   * @generated from enum value: CHALLENGE_BONUS = 3;
   */
  CHALLENGE_BONUS = 3,

  /**
   * @generated from enum value: EXCHANGE = 4;
   */
  EXCHANGE = 4,

  /**
   * @generated from enum value: END_RACK_PTS = 5;
   */
  END_RACK_PTS = 5,

  /**
   * @generated from enum value: TIME_PENALTY = 6;
   */
  TIME_PENALTY = 6,

  /**
   * Only for international rules (or after 6 zeroes)
   *
   * @generated from enum value: END_RACK_PENALTY = 7;
   */
  END_RACK_PENALTY = 7,

  /**
   * Lose a turn for challenging a word incorrectly (only for double
   * challenge)
   *
   * @generated from enum value: UNSUCCESSFUL_CHALLENGE_TURN_LOSS = 8;
   */
  UNSUCCESSFUL_CHALLENGE_TURN_LOSS = 8,

  /**
   * Issue a challenge
   *
   * @generated from enum value: CHALLENGE = 9;
   */
  CHALLENGE = 9,

  /**
   * @generated from enum value: TIMED_OUT = 10;
   */
  TIMED_OUT = 10,

  /**
   * @generated from enum value: RESIGNED = 11;
   */
  RESIGNED = 11,
}

/**
 * @generated from enum ipc.GameEvent.Direction
 */
export declare enum GameEvent_Direction {
  /**
   * @generated from enum value: HORIZONTAL = 0;
   */
  HORIZONTAL = 0,

  /**
   * @generated from enum value: VERTICAL = 1;
   */
  VERTICAL = 1,
}

/**
 * @generated from message ipc.Timers
 */
export declare class Timers extends Message<Timers> {
  /**
   * time_of_last_update is the timestamp of the last update, in milliseconds
   * If no update has been made, this defaults to timeStarted.
   *
   * @generated from field: int64 time_of_last_update = 1;
   */
  timeOfLastUpdate: bigint;

  /**
   * time_started is a unix timestamp, in milliseconds.
   *
   * @generated from field: int64 time_started = 2;
   */
  timeStarted: bigint;

  /**
   * time_remaining is an array of remaining time per player, in milliseconds
   *
   * @generated from field: repeated int64 time_remaining = 3;
   */
  timeRemaining: bigint[];

  /**
   * max_overtime is the number of minutes that the game is allowed to go
   * overtime
   *
   * @generated from field: int32 max_overtime = 4;
   */
  maxOvertime: number;

  /**
   * increment_seconds is the amount of seconds that is added to the timer
   * after every move
   *
   * @generated from field: int32 increment_seconds = 5;
   */
  incrementSeconds: number;

  /**
   * reset_to_increment_after_turn sets the timer for the player to
   * increment_seconds. this can be used for correspondence games; for example,
   * time_remaining and increment_seconds can be set to the same number of
   * seconds (let's say 5 days) at the beginning, and this flag can be set to
   * on. Then we should always have 5 days to make any move.
   *
   * @generated from field: bool reset_to_increment_after_turn = 6;
   */
  resetToIncrementAfterTurn: boolean;

  /**
   * If untimed is true, then Timers are not updated at all.
   *
   * @generated from field: bool untimed = 7;
   */
  untimed: boolean;

  constructor(data?: PartialMessage<Timers>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.Timers";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Timers;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Timers;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Timers;

  static equals(a: Timers | PlainMessage<Timers> | undefined, b: Timers | PlainMessage<Timers> | undefined): boolean;
}

/**
 * @generated from message ipc.MetaEventData
 */
export declare class MetaEventData extends Message<MetaEventData> {
  /**
   * @generated from field: repeated ipc.GameMetaEvent events = 1;
   */
  events: GameMetaEvent[];

  constructor(data?: PartialMessage<MetaEventData>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.MetaEventData";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetaEventData;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetaEventData;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetaEventData;

  static equals(a: MetaEventData | PlainMessage<MetaEventData> | undefined, b: MetaEventData | PlainMessage<MetaEventData> | undefined): boolean;
}

/**
 * @generated from message ipc.GameBoard
 */
export declare class GameBoard extends Message<GameBoard> {
  /**
   * @generated from field: int32 num_rows = 1;
   */
  numRows: number;

  /**
   * @generated from field: int32 num_cols = 2;
   */
  numCols: number;

  /**
   * tiles are laid out in row-major form
   *
   * @generated from field: bytes tiles = 3;
   */
  tiles: Uint8Array;

  /**
   *   repeated int32 h_cross_scores = 4;
   *   repeated int32 v_cross_scores = 5;
   *
   * @generated from field: bool is_empty = 4;
   */
  isEmpty: boolean;

  constructor(data?: PartialMessage<GameBoard>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameBoard";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameBoard;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameBoard;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameBoard;

  static equals(a: GameBoard | PlainMessage<GameBoard> | undefined, b: GameBoard | PlainMessage<GameBoard> | undefined): boolean;
}

/**
 * @generated from message ipc.Bag
 */
export declare class Bag extends Message<Bag> {
  /**
   * @generated from field: bytes tiles = 1;
   */
  tiles: Uint8Array;

  constructor(data?: PartialMessage<Bag>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.Bag";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bag;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bag;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bag;

  static equals(a: Bag | PlainMessage<Bag> | undefined, b: Bag | PlainMessage<Bag> | undefined): boolean;
}

/**
 * A GameDocument encodes the entire state of a game. It includes a history
 * of events, as well as information about the current state of the bag,
 * timers, etc. It should be possible to recreate an entire omgwords game
 * from a GameDocument state at any given time.
 *
 * @generated from message ipc.GameDocument
 */
export declare class GameDocument extends Message<GameDocument> {
  /**
   * players are in order of who went first.
   *
   * @generated from field: repeated ipc.GameDocument.MinimalPlayerInfo players = 1;
   */
  players: GameDocument_MinimalPlayerInfo[];

  /**
   * @generated from field: repeated ipc.GameEvent events = 2;
   */
  events: GameEvent[];

  /**
   * @generated from field: uint32 version = 3;
   */
  version: number;

  /**
   * @generated from field: string lexicon = 4;
   */
  lexicon: string;

  /**
   * @generated from field: string uid = 5;
   */
  uid: string;

  /**
   * @generated from field: string description = 6;
   */
  description: string;

  /**
   * @generated from field: repeated bytes racks = 7;
   */
  racks: Uint8Array[];

  /**
   * @generated from field: ipc.ChallengeRule challenge_rule = 8;
   */
  challengeRule: ChallengeRule;

  /**
   * @generated from field: ipc.PlayState play_state = 9;
   */
  playState: PlayState;

  /**
   * @generated from field: repeated int32 current_scores = 10;
   */
  currentScores: number[];

  /**
   * @generated from field: string variant = 11;
   */
  variant: string;

  /**
   * The index of the player who won, or -1 if it was a tie.
   *
   * @generated from field: int32 winner = 12;
   */
  winner: number;

  /**
   * The board layout is just the name for the layout of the board.
   * It should have a sensible default, if blank.
   *
   * @generated from field: string board_layout = 13;
   */
  boardLayout: string;

  /**
   * The letter distribution is the name of the distribution of tiles used for
   * this game. If blank, should default to "english".
   *
   * @generated from field: string letter_distribution = 14;
   */
  letterDistribution: string;

  /**
   * @generated from field: ipc.GameType type = 15;
   */
  type: GameType;

  /**
   * @generated from field: bool timers_started = 16;
   */
  timersStarted: boolean;

  /**
   * @generated from field: ipc.GameEndReason end_reason = 17;
   */
  endReason: GameEndReason;

  /**
   * @generated from field: ipc.MetaEventData meta_event_data = 18;
   */
  metaEventData?: MetaEventData;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 19;
   */
  createdAt?: Timestamp;

  /**
   * gameplay-specific structures:
   * board is the current state of the board
   *
   * @generated from field: ipc.GameBoard board = 20;
   */
  board?: GameBoard;

  /**
   * bag is the current tiles in the bag.
   *
   * @generated from field: ipc.Bag bag = 21;
   */
  bag?: Bag;

  /**
   * @generated from field: uint32 scoreless_turns = 22;
   */
  scorelessTurns: number;

  /**
   * The index of the player on turn
   *
   * @generated from field: uint32 player_on_turn = 23;
   */
  playerOnTurn: number;

  /**
   * @generated from field: ipc.Timers timers = 24;
   */
  timers?: Timers;

  constructor(data?: PartialMessage<GameDocument>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameDocument";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameDocument;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameDocument;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameDocument;

  static equals(a: GameDocument | PlainMessage<GameDocument> | undefined, b: GameDocument | PlainMessage<GameDocument> | undefined): boolean;
}

/**
 * @generated from message ipc.GameDocument.MinimalPlayerInfo
 */
export declare class GameDocument_MinimalPlayerInfo extends Message<GameDocument_MinimalPlayerInfo> {
  /**
   * @generated from field: string nickname = 1;
   */
  nickname: string;

  /**
   * @generated from field: string real_name = 2;
   */
  realName: string;

  /**
   * user_id is an internal, unchangeable user ID, whereas the other two user
   * identifiers might possibly be mutable.
   *
   * @generated from field: string user_id = 3;
   */
  userId: string;

  /**
   * @generated from field: bool quit = 4;
   */
  quit: boolean;

  constructor(data?: PartialMessage<GameDocument_MinimalPlayerInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ipc.GameDocument.MinimalPlayerInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GameDocument_MinimalPlayerInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GameDocument_MinimalPlayerInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GameDocument_MinimalPlayerInfo;

  static equals(a: GameDocument_MinimalPlayerInfo | PlainMessage<GameDocument_MinimalPlayerInfo> | undefined, b: GameDocument_MinimalPlayerInfo | PlainMessage<GameDocument_MinimalPlayerInfo> | undefined): boolean;
}

